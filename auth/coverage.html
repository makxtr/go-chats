
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">auth/cmd/server/main.go (0.0%)</option>
				
				<option value="file2">auth/internal/api/user/create.go (0.0%)</option>
				
				<option value="file3">auth/internal/api/user/delete.go (0.0%)</option>
				
				<option value="file4">auth/internal/api/user/errors.go (0.0%)</option>
				
				<option value="file5">auth/internal/api/user/get.go (0.0%)</option>
				
				<option value="file6">auth/internal/api/user/service.go (0.0%)</option>
				
				<option value="file7">auth/internal/api/user/update.go (0.0%)</option>
				
				<option value="file8">auth/internal/app/app.go (0.0%)</option>
				
				<option value="file9">auth/internal/app/service_provider.go (0.0%)</option>
				
				<option value="file10">auth/internal/config/config.go (0.0%)</option>
				
				<option value="file11">auth/internal/config/grpc.go (0.0%)</option>
				
				<option value="file12">auth/internal/config/pg.go (0.0%)</option>
				
				<option value="file13">auth/internal/converter/user.go (0.0%)</option>
				
				<option value="file14">auth/internal/model/user.go (0.0%)</option>
				
				<option value="file15">auth/internal/repository/mocks/log_repository_minimock.go (0.0%)</option>
				
				<option value="file16">auth/internal/repository/mocks/user_repository_minimock.go (0.0%)</option>
				
				<option value="file17">auth/internal/repository/user/converter/user.go (0.0%)</option>
				
				<option value="file18">auth/internal/repository/user/model/user.go (0.0%)</option>
				
				<option value="file19">auth/internal/repository/user/repository.go (0.0%)</option>
				
				<option value="file20">auth/internal/service/user/create.go (0.0%)</option>
				
				<option value="file21">auth/internal/service/user/delete.go (0.0%)</option>
				
				<option value="file22">auth/internal/service/user/get.go (0.0%)</option>
				
				<option value="file23">auth/internal/service/user/service.go (0.0%)</option>
				
				<option value="file24">auth/internal/service/user/update.go (0.0%)</option>
				
				<option value="file25">auth/pkg/user_v1/user.pb.go (0.0%)</option>
				
				<option value="file26">auth/pkg/user_v1/user_grpc.pb.go (0.0%)</option>
				
				<option value="file27">auth/test_cloud_auth.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "log"
        "time"

        "github.com/fatih/color"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        desc "auth/pkg/user_v1"
)

const (
        address = "localhost:50051"
        userID  = 12
)

func main() <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect to server: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        c := desc.NewUserV1Client(conn)

        ctx, cancel := context.WithTimeout(context.Background(), time.Second)
        defer cancel()

        r, err := c.Get(ctx, &amp;desc.GetRequest{Id: userID})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to get user by id: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("%s %s\n", color.RedString("User info:"), color.GreenString("%+v", r.GetUser()))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "auth/internal/app"
        "context"
        "flag"
        "log"
)

var configPath string

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;configPath, "config-path", ".env", "path to config file")
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()
        ctx := context.Background()

        a, err := app.NewApp(ctx, configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to init app: %s", err.Error())
        }</span>

        <span class="cov0" title="0">err = a.Run()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to run app: %s", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package user

import (
        "auth/internal/converter"
        desc "auth/pkg/user_v1"
        "context"
        "log"
)

func (i *Implementation) Create(ctx context.Context, req *desc.CreateRequest) (*desc.CreateResponse, error) <span class="cov0" title="0">{
        id, err := i.userService.Create(ctx, converter.ToUserCreateFromDesc(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapError(err)
        }</span>

        <span class="cov0" title="0">log.Printf("inserted user with id: %d", id)

        return &amp;desc.CreateResponse{
                Id: id,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package user

import (
        desc "auth/pkg/user_v1"
        "context"
        "log"

        "google.golang.org/protobuf/types/known/emptypb"
)

func (i *Implementation) Delete(ctx context.Context, req *desc.DeleteRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := i.userService.Delete(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapError(err)
        }</span>

        <span class="cov0" title="0">log.Printf("deleted user with id: %d", req.GetId())

        return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package user

import (
        "auth/internal/repository"
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func mapError(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch </span>{
        case errors.Is(err, repository.ErrNotFound):<span class="cov0" title="0">
                return status.Error(codes.NotFound, "user not found")</span>
        case errors.Is(err, repository.ErrQueryBuild):<span class="cov0" title="0">
                return status.Error(codes.Internal, "internal error: failed to build query")</span>
        case errors.Is(err, repository.ErrCreateFailed):<span class="cov0" title="0">
                return status.Error(codes.Internal, "failed to create user")</span>
        case errors.Is(err, repository.ErrUpdateFailed):<span class="cov0" title="0">
                return status.Error(codes.Internal, "failed to update user")</span>
        case errors.Is(err, repository.ErrDeleteFailed):<span class="cov0" title="0">
                return status.Error(codes.Internal, "failed to delete user")</span>
        default:<span class="cov0" title="0">
                return status.Error(codes.Internal, err.Error())</span>
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package user

import (
        "auth/internal/converter"
        desc "auth/pkg/user_v1"
        "context"
        "log"
)

func (i *Implementation) Get(ctx context.Context, req *desc.GetRequest) (*desc.GetResponse, error) <span class="cov0" title="0">{
        user, err := i.userService.Get(ctx, req.GetId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapError(err)
        }</span>

        <span class="cov0" title="0">log.Printf("id: %d, name: %s, email: %s, created_at: %v, updated_at: %v\n", user.ID, user.Info.Name, user.Info.Email, user.CreatedAt, user.UpdatedAt)

        return &amp;desc.GetResponse{
                User: converter.ToUserFromService(user),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package user

import (
        "auth/internal/service"
        desc "auth/pkg/user_v1"
)

type Implementation struct {
        desc.UnimplementedUserV1Server
        userService service.UserService
}

func NewImplementation(userService service.UserService) *Implementation <span class="cov0" title="0">{
        return &amp;Implementation{
                userService: userService,
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package user

import (
        "auth/internal/converter"
        desc "auth/pkg/user_v1"
        "context"
        "log"

        "google.golang.org/protobuf/types/known/emptypb"
)

func (i *Implementation) Update(ctx context.Context, req *desc.UpdateRequest) (*emptypb.Empty, error) <span class="cov0" title="0">{
        err := i.userService.Update(ctx, req.GetId(), converter.ToUserUpdateFromDesc(req))
        if err != nil </span><span class="cov0" title="0">{
                return nil, mapError(err)
        }</span>

        <span class="cov0" title="0">log.Printf("updated user with id: %d", req.GetId())

        return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "auth/internal/config"
        desc "auth/pkg/user_v1"
        "context"
        "log"
        "net"

        "github.com/makxtr/go-common/pkg/closer"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/reflection"
)

type App struct {
        serviceProvider *serviceProvider
        grpcServer      *grpc.Server
}

func NewApp(ctx context.Context, configPath string) (*App, error) <span class="cov0" title="0">{
        a := &amp;App{}

        err := a.initDeps(ctx, configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return a, nil</span>
}

func (a *App) Run() error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                closer.CloseAll()
                closer.Wait()
        }</span>()

        <span class="cov0" title="0">return a.runGRPCServer()</span>
}

func (a *App) initDeps(ctx context.Context, configPath string) error <span class="cov0" title="0">{
        inits := []func(context.Context) error{
                func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return a.initConfig(ctx, configPath)
                }</span>,
                a.initServiceProvider,
                a.initGRPCServer,
        }

        <span class="cov0" title="0">for _, f := range inits </span><span class="cov0" title="0">{
                err := f(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *App) initConfig(_ context.Context, configPath string) error <span class="cov0" title="0">{
        err := config.Load(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *App) initServiceProvider(_ context.Context) error <span class="cov0" title="0">{
        a.serviceProvider = newServiceProvider()
        return nil
}</span>

func (a *App) initGRPCServer(ctx context.Context) error <span class="cov0" title="0">{
        a.grpcServer = grpc.NewServer(grpc.Creds(insecure.NewCredentials()))

        reflection.Register(a.grpcServer)

        desc.RegisterUserV1Server(a.grpcServer, a.serviceProvider.UserImpl(ctx))

        return nil
}</span>

func (a *App) runGRPCServer() error <span class="cov0" title="0">{
        log.Printf("GRPC server is running on %s", a.serviceProvider.GRPCConfig().Address())

        list, err := net.Listen("tcp", a.serviceProvider.GRPCConfig().Address())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = a.grpcServer.Serve(list)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "auth/internal/api/user"
        "auth/internal/config"
        "auth/internal/repository"
        userRepository "auth/internal/repository/user"
        "auth/internal/service"
        userService "auth/internal/service/user"
        "context"
        "log"

        "github.com/makxtr/go-common/pkg/closer"
        "github.com/makxtr/go-common/pkg/db"
        "github.com/makxtr/go-common/pkg/db/pg"
        "github.com/makxtr/go-common/pkg/db/transaction"
        "github.com/makxtr/go-common/pkg/logger"
)

type serviceProvider struct {
        pgConfig   config.PGConfig
        grpcConfig config.GRPCConfig

        dbClient       db.Client
        txManager      db.TxManager
        userRepository repository.UserRepository
        logRepository  repository.LogRepository

        userService service.UserService

        userImpl *user.Implementation
}

func newServiceProvider() *serviceProvider <span class="cov0" title="0">{
        return &amp;serviceProvider{}
}</span>

func (s *serviceProvider) PGConfig() config.PGConfig <span class="cov0" title="0">{
        if s.pgConfig == nil </span><span class="cov0" title="0">{
                cfg, err := config.NewPGConfig()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to get pg config: %s", err.Error())
                }</span>

                <span class="cov0" title="0">s.pgConfig = cfg</span>
        }

        <span class="cov0" title="0">return s.pgConfig</span>
}

func (s *serviceProvider) GRPCConfig() config.GRPCConfig <span class="cov0" title="0">{
        if s.grpcConfig == nil </span><span class="cov0" title="0">{
                cfg, err := config.NewGRPCConfig()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to get grpc config: %s", err.Error())
                }</span>

                <span class="cov0" title="0">s.grpcConfig = cfg</span>
        }

        <span class="cov0" title="0">return s.grpcConfig</span>
}

func (s *serviceProvider) DBClient(ctx context.Context) db.Client <span class="cov0" title="0">{
        if s.dbClient == nil </span><span class="cov0" title="0">{
                cl, err := pg.New(ctx, s.PGConfig().DSN())
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to create db client: %v", err)
                }</span>

                <span class="cov0" title="0">err = cl.DB().Ping(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("ping error: %s", err.Error())
                }</span>
                <span class="cov0" title="0">closer.Add(cl.Close)

                s.dbClient = cl</span>
        }

        <span class="cov0" title="0">return s.dbClient</span>
}

func (s *serviceProvider) TxManager(ctx context.Context) db.TxManager <span class="cov0" title="0">{
        if s.txManager == nil </span><span class="cov0" title="0">{
                s.txManager = transaction.NewTransactionManager(s.DBClient(ctx).DB())
        }</span>

        <span class="cov0" title="0">return s.txManager</span>
}

func (s *serviceProvider) UserRepository(ctx context.Context) repository.UserRepository <span class="cov0" title="0">{
        if s.userRepository == nil </span><span class="cov0" title="0">{
                s.userRepository = userRepository.NewRepository(s.DBClient(ctx))
        }</span>

        <span class="cov0" title="0">return s.userRepository</span>
}

func (s *serviceProvider) LogRepository(ctx context.Context) repository.LogRepository <span class="cov0" title="0">{
        if s.logRepository == nil </span><span class="cov0" title="0">{
                s.logRepository = logger.NewRepository(s.DBClient(ctx), "user_logs")
        }</span>

        <span class="cov0" title="0">return s.logRepository</span>
}

func (s *serviceProvider) UserService(ctx context.Context) service.UserService <span class="cov0" title="0">{
        if s.userService == nil </span><span class="cov0" title="0">{
                s.userService = userService.NewService(
                        s.UserRepository(ctx),
                        s.LogRepository(ctx),
                        s.TxManager(ctx),
                )
        }</span>

        <span class="cov0" title="0">return s.userService</span>
}

func (s *serviceProvider) UserImpl(ctx context.Context) *user.Implementation <span class="cov0" title="0">{
        if s.userImpl == nil </span><span class="cov0" title="0">{
                s.userImpl = user.NewImplementation(s.UserService(ctx))
        }</span>

        <span class="cov0" title="0">return s.userImpl</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "github.com/joho/godotenv"
)

func Load(path string) error <span class="cov0" title="0">{
        err := godotenv.Load(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "net"
        "os"

        "github.com/pkg/errors"
)

const (
        grpcHostEnvName  = "GRPC_HOST"
        grpcPortEnvName  = "GRPC_PORT"
        cloudPortEnvName = "PORT"
)

type GRPCConfig interface {
        Address() string
}

type grpcConfig struct {
        host string
        port string
}

func NewGRPCConfig() (GRPCConfig, error) <span class="cov0" title="0">{
        host := os.Getenv(grpcHostEnvName)
        if len(host) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("grpc host not found")
        }</span>

        <span class="cov0" title="0">port := os.Getenv(cloudPortEnvName)
        if len(port) == 0 </span><span class="cov0" title="0">{
                port = os.Getenv(grpcPortEnvName)
                if len(port) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("grpc port not found")
                }</span>
        }

        <span class="cov0" title="0">return &amp;grpcConfig{
                host: host,
                port: port,
        }, nil</span>
}

func (cfg *grpcConfig) Address() string <span class="cov0" title="0">{
        return net.JoinHostPort(cfg.host, cfg.port)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "errors"
        "os"
)

const (
        dsnEnvName = "PG_DSN"
)

type PGConfig interface {
        DSN() string
}

type pgConfig struct {
        dsn string
}

func NewPGConfig() (PGConfig, error) <span class="cov0" title="0">{
        dsn := os.Getenv(dsnEnvName)
        if len(dsn) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("pg dsn not found")
        }</span>

        <span class="cov0" title="0">return &amp;pgConfig{
                dsn: dsn,
        }, nil</span>
}

func (cfg *pgConfig) DSN() string <span class="cov0" title="0">{
        return cfg.dsn
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package converter

import (
        "auth/internal/model"
        desc "auth/pkg/user_v1"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func ToUserCreateFromDesc(req *desc.CreateRequest) *model.CreateUserCommand <span class="cov0" title="0">{
        return &amp;model.CreateUserCommand{
                Info: model.UserInfo{
                        Name:  req.GetName(),
                        Email: req.GetEmail(),
                        Role:  model.Role(req.GetRole()),
                },
                Password:        req.GetPassword(),
                PasswordConfirm: req.GetPasswordConfirm(),
        }
}</span>

func ToUserUpdateFromDesc(req *desc.UpdateRequest) *model.UpdateUserData <span class="cov0" title="0">{
        var name, email *string
        if req.GetInfo().GetName() != nil </span><span class="cov0" title="0">{
                val := req.GetInfo().GetName().GetValue()
                name = &amp;val
        }</span>
        <span class="cov0" title="0">if req.GetInfo().GetEmail() != nil </span><span class="cov0" title="0">{
                val := req.GetInfo().GetEmail().GetValue()
                email = &amp;val
        }</span>

        <span class="cov0" title="0">return &amp;model.UpdateUserData{
                Name:  name,
                Email: email,
        }</span>
}

func ToUserFromService(user *model.User) *desc.User <span class="cov0" title="0">{
        var updatedAt *timestamppb.Timestamp
        if user.UpdatedAt.Valid </span><span class="cov0" title="0">{
                updatedAt = timestamppb.New(user.UpdatedAt.Time)
        }</span>

        <span class="cov0" title="0">return &amp;desc.User{
                Id:        user.ID,
                Name:      user.Info.Name,
                Email:     user.Info.Email,
                Role:      desc.Role(user.Info.Role),
                CreatedAt: timestamppb.New(user.CreatedAt),
                UpdatedAt: updatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import (
        "database/sql"
        "errors"
        "time"
)

type User struct {
        ID        int64
        Info      UserInfo
        CreatedAt time.Time
        UpdatedAt sql.NullTime
}

type UserInfo struct {
        Name  string
        Email string
        Role  Role
}

type CreateUserCommand struct {
        Info            UserInfo
        Password        string
        PasswordConfirm string
}

func (c *CreateUserCommand) Validate() error <span class="cov0" title="0">{
        if c.Password != c.PasswordConfirm </span><span class="cov0" title="0">{
                return errors.New("passwords do not match")
        }</span>
        <span class="cov0" title="0">if len(c.Password) &lt; 8 </span><span class="cov0" title="0">{
                return errors.New("password must be at least 8 characters")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateUserData struct {
        Info           UserInfo
        HashedPassword string
}

type UpdateUserData struct {
        Name  *string
        Email *string
}

type Role int32

const (
        RoleUnspecified Role = iota
        RoleUser
        RoleAdmin
)

func (r Role) String() string <span class="cov0" title="0">{
        switch r </span>{
        case RoleUser:<span class="cov0" title="0">
                return "USER"</span>
        case RoleAdmin:<span class="cov0" title="0">
                return "ADMIN"</span>
        default:<span class="cov0" title="0">
                return "UNSPECIFIED"</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i auth/internal/repository.LogRepository -o log_repository_minimock.go -n LogRepositoryMock -p mocks

import (
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
        logModel "github.com/makxtr/go-common/pkg/logger/model"
)

// LogRepositoryMock implements mm_repository.LogRepository
type LogRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcLog          func(ctx context.Context, log *logModel.Log) (err error)
        funcLogOrigin    string
        inspectFuncLog   func(ctx context.Context, log *logModel.Log)
        afterLogCounter  uint64
        beforeLogCounter uint64
        LogMock          mLogRepositoryMockLog
}

// NewLogRepositoryMock returns a mock for mm_repository.LogRepository
func NewLogRepositoryMock(t minimock.Tester) *LogRepositoryMock <span class="cov0" title="0">{
        m := &amp;LogRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.LogMock = mLogRepositoryMockLog{mock: m}
        m.LogMock.callArgs = []*LogRepositoryMockLogParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mLogRepositoryMockLog struct {
        optional           bool
        mock               *LogRepositoryMock
        defaultExpectation *LogRepositoryMockLogExpectation
        expectations       []*LogRepositoryMockLogExpectation

        callArgs []*LogRepositoryMockLogParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// LogRepositoryMockLogExpectation specifies expectation struct of the LogRepository.Log
type LogRepositoryMockLogExpectation struct {
        mock               *LogRepositoryMock
        params             *LogRepositoryMockLogParams
        paramPtrs          *LogRepositoryMockLogParamPtrs
        expectationOrigins LogRepositoryMockLogExpectationOrigins
        results            *LogRepositoryMockLogResults
        returnOrigin       string
        Counter            uint64
}

// LogRepositoryMockLogParams contains parameters of the LogRepository.Log
type LogRepositoryMockLogParams struct {
        ctx context.Context
        log *logModel.Log
}

// LogRepositoryMockLogParamPtrs contains pointers to parameters of the LogRepository.Log
type LogRepositoryMockLogParamPtrs struct {
        ctx *context.Context
        log **logModel.Log
}

// LogRepositoryMockLogResults contains results of the LogRepository.Log
type LogRepositoryMockLogResults struct {
        err error
}

// LogRepositoryMockLogOrigins contains origins of expectations of the LogRepository.Log
type LogRepositoryMockLogExpectationOrigins struct {
        origin    string
        originCtx string
        originLog string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLog *mLogRepositoryMockLog) Optional() *mLogRepositoryMockLog <span class="cov0" title="0">{
        mmLog.optional = true
        return mmLog
}</span>

// Expect sets up expected params for LogRepository.Log
func (mmLog *mLogRepositoryMockLog) Expect(ctx context.Context, log *logModel.Log) *mLogRepositoryMockLog <span class="cov0" title="0">{
        if mmLog.mock.funcLog != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLog.defaultExpectation = &amp;LogRepositoryMockLogExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmLog.defaultExpectation.params = &amp;LogRepositoryMockLogParams{ctx, log}
        mmLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmLog.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmLog.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmLog</span>
}

// ExpectCtxParam1 sets up expected param ctx for LogRepository.Log
func (mmLog *mLogRepositoryMockLog) ExpectCtxParam1(ctx context.Context) *mLogRepositoryMockLog <span class="cov0" title="0">{
        if mmLog.mock.funcLog != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLog.defaultExpectation = &amp;LogRepositoryMockLogExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmLog.defaultExpectation.paramPtrs = &amp;LogRepositoryMockLogParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmLog.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmLog</span>
}

// ExpectLogParam2 sets up expected param log for LogRepository.Log
func (mmLog *mLogRepositoryMockLog) ExpectLogParam2(log *logModel.Log) *mLogRepositoryMockLog <span class="cov0" title="0">{
        if mmLog.mock.funcLog != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLog.defaultExpectation = &amp;LogRepositoryMockLogExpectation{}
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmLog.defaultExpectation.paramPtrs = &amp;LogRepositoryMockLogParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmLog.defaultExpectation.paramPtrs.log = &amp;log
        mmLog.defaultExpectation.expectationOrigins.originLog = minimock.CallerInfo(1)

        return mmLog</span>
}

// Inspect accepts an inspector function that has same arguments as the LogRepository.Log
func (mmLog *mLogRepositoryMockLog) Inspect(f func(ctx context.Context, log *logModel.Log)) *mLogRepositoryMockLog <span class="cov0" title="0">{
        if mmLog.mock.inspectFuncLog != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("Inspect function is already set for LogRepositoryMock.Log")
        }</span>

        <span class="cov0" title="0">mmLog.mock.inspectFuncLog = f

        return mmLog</span>
}

// Return sets up results that will be returned by LogRepository.Log
func (mmLog *mLogRepositoryMockLog) Return(err error) *LogRepositoryMock <span class="cov0" title="0">{
        if mmLog.mock.funcLog != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmLog.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmLog.defaultExpectation = &amp;LogRepositoryMockLogExpectation{mock: mmLog.mock}
        }</span>
        <span class="cov0" title="0">mmLog.defaultExpectation.results = &amp;LogRepositoryMockLogResults{err}
        mmLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmLog.mock</span>
}

// Set uses given function f to mock the LogRepository.Log method
func (mmLog *mLogRepositoryMockLog) Set(f func(ctx context.Context, log *logModel.Log) (err error)) *LogRepositoryMock <span class="cov0" title="0">{
        if mmLog.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("Default expectation is already set for the LogRepository.Log method")
        }</span>

        <span class="cov0" title="0">if len(mmLog.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("Some expectations are already set for the LogRepository.Log method")
        }</span>

        <span class="cov0" title="0">mmLog.mock.funcLog = f
        mmLog.mock.funcLogOrigin = minimock.CallerInfo(1)
        return mmLog.mock</span>
}

// When sets expectation for the LogRepository.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mLogRepositoryMockLog) When(ctx context.Context, log *logModel.Log) *LogRepositoryMockLogExpectation <span class="cov0" title="0">{
        if mmLog.mock.funcLog != nil </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("LogRepositoryMock.Log mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;LogRepositoryMockLogExpectation{
                mock:               mmLog.mock,
                params:             &amp;LogRepositoryMockLogParams{ctx, log},
                expectationOrigins: LogRepositoryMockLogExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmLog.expectations = append(mmLog.expectations, expectation)
        return expectation</span>
}

// Then sets up LogRepository.Log return parameters for the expectation previously defined by the When method
func (e *LogRepositoryMockLogExpectation) Then(err error) *LogRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;LogRepositoryMockLogResults{err}
        return e.mock
}</span>

// Times sets number of times LogRepository.Log should be invoked
func (mmLog *mLogRepositoryMockLog) Times(n uint64) *mLogRepositoryMockLog <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmLog.mock.t.Fatalf("Times of LogRepositoryMock.Log mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmLog.expectedInvocations, n)
        mmLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmLog</span>
}

func (mmLog *mLogRepositoryMockLog) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmLog.expectations) == 0 &amp;&amp; mmLog.defaultExpectation == nil &amp;&amp; mmLog.mock.funcLog == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmLog.mock.afterLogCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmLog.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Log implements mm_repository.LogRepository
func (mmLog *LogRepositoryMock) Log(ctx context.Context, log *logModel.Log) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmLog.beforeLogCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmLog.afterLogCounter, 1)

        mmLog.t.Helper()

        if mmLog.inspectFuncLog != nil </span><span class="cov0" title="0">{
                mmLog.inspectFuncLog(ctx, log)
        }</span>

        <span class="cov0" title="0">mm_params := LogRepositoryMockLogParams{ctx, log}

        // Record call args
        mmLog.LogMock.mutex.Lock()
        mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, &amp;mm_params)
        mmLog.LogMock.mutex.Unlock()

        for _, e := range mmLog.LogMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmLog.LogMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmLog.LogMock.defaultExpectation.Counter, 1)
                mm_want := mmLog.LogMock.defaultExpectation.params
                mm_want_ptrs := mmLog.LogMock.defaultExpectation.paramPtrs

                mm_got := LogRepositoryMockLogParams{ctx, log}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmLog.t.Errorf("LogRepositoryMock.Log got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmLog.LogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.log != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.log, mm_got.log) </span><span class="cov0" title="0">{
                                mmLog.t.Errorf("LogRepositoryMock.Log got unexpected parameter log, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmLog.LogMock.defaultExpectation.expectationOrigins.originLog, *mm_want_ptrs.log, mm_got.log, minimock.Diff(*mm_want_ptrs.log, mm_got.log))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmLog.t.Errorf("LogRepositoryMock.Log got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmLog.LogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmLog.LogMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmLog.t.Fatal("No results are set for the LogRepositoryMock.Log")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmLog.funcLog != nil </span><span class="cov0" title="0">{
                return mmLog.funcLog(ctx, log)
        }</span>
        <span class="cov0" title="0">mmLog.t.Fatalf("Unexpected call to LogRepositoryMock.Log. %v %v", ctx, log)
        return</span>
}

// LogAfterCounter returns a count of finished LogRepositoryMock.Log invocations
func (mmLog *LogRepositoryMock) LogAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmLog.afterLogCounter)
}</span>

// LogBeforeCounter returns a count of LogRepositoryMock.Log invocations
func (mmLog *LogRepositoryMock) LogBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmLog.beforeLogCounter)
}</span>

// Calls returns a list of arguments used in each call to LogRepositoryMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mLogRepositoryMockLog) Calls() []*LogRepositoryMockLogParams <span class="cov0" title="0">{
        mmLog.mutex.RLock()

        argCopy := make([]*LogRepositoryMockLogParams, len(mmLog.callArgs))
        copy(argCopy, mmLog.callArgs)

        mmLog.mutex.RUnlock()

        return argCopy
}</span>

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *LogRepositoryMock) MinimockLogDone() bool <span class="cov0" title="0">{
        if m.LogMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.LogMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.LogMock.invocationsDone()</span>
}

// MinimockLogInspect logs each unmet expectation
func (m *LogRepositoryMock) MinimockLogInspect() <span class="cov0" title="0">{
        for _, e := range m.LogMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to LogRepositoryMock.Log at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterLogCounter := mm_atomic.LoadUint64(&amp;m.afterLogCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.LogMock.defaultExpectation != nil &amp;&amp; afterLogCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.LogMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to LogRepositoryMock.Log at\n%s", m.LogMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to LogRepositoryMock.Log at\n%s with params: %#v", m.LogMock.defaultExpectation.expectationOrigins.origin, *m.LogMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcLog != nil &amp;&amp; afterLogCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to LogRepositoryMock.Log at\n%s", m.funcLogOrigin)
        }</span>

        <span class="cov0" title="0">if !m.LogMock.invocationsDone() &amp;&amp; afterLogCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to LogRepositoryMock.Log at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.LogMock.expectedInvocations), m.LogMock.expectedInvocationsOrigin, afterLogCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LogRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockLogInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LogRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *LogRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockLogDone()
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i auth/internal/repository.UserRepository -o user_repository_minimock.go -n UserRepositoryMock -p mocks

import (
        "auth/internal/model"
        "context"
        "sync"
        mm_atomic "sync/atomic"
        mm_time "time"

        "github.com/gojuno/minimock/v3"
)

// UserRepositoryMock implements mm_repository.UserRepository
type UserRepositoryMock struct {
        t          minimock.Tester
        finishOnce sync.Once

        funcCreate          func(ctx context.Context, createUser *model.CreateUserData) (i1 int64, err error)
        funcCreateOrigin    string
        inspectFuncCreate   func(ctx context.Context, createUser *model.CreateUserData)
        afterCreateCounter  uint64
        beforeCreateCounter uint64
        CreateMock          mUserRepositoryMockCreate

        funcDelete          func(ctx context.Context, id int64) (err error)
        funcDeleteOrigin    string
        inspectFuncDelete   func(ctx context.Context, id int64)
        afterDeleteCounter  uint64
        beforeDeleteCounter uint64
        DeleteMock          mUserRepositoryMockDelete

        funcGet          func(ctx context.Context, id int64) (up1 *model.User, err error)
        funcGetOrigin    string
        inspectFuncGet   func(ctx context.Context, id int64)
        afterGetCounter  uint64
        beforeGetCounter uint64
        GetMock          mUserRepositoryMockGet

        funcUpdate          func(ctx context.Context, id int64, updateUser *model.UpdateUserData) (err error)
        funcUpdateOrigin    string
        inspectFuncUpdate   func(ctx context.Context, id int64, updateUser *model.UpdateUserData)
        afterUpdateCounter  uint64
        beforeUpdateCounter uint64
        UpdateMock          mUserRepositoryMockUpdate
}

// NewUserRepositoryMock returns a mock for mm_repository.UserRepository
func NewUserRepositoryMock(t minimock.Tester) *UserRepositoryMock <span class="cov0" title="0">{
        m := &amp;UserRepositoryMock{t: t}

        if controller, ok := t.(minimock.MockController); ok </span><span class="cov0" title="0">{
                controller.RegisterMocker(m)
        }</span>

        <span class="cov0" title="0">m.CreateMock = mUserRepositoryMockCreate{mock: m}
        m.CreateMock.callArgs = []*UserRepositoryMockCreateParams{}

        m.DeleteMock = mUserRepositoryMockDelete{mock: m}
        m.DeleteMock.callArgs = []*UserRepositoryMockDeleteParams{}

        m.GetMock = mUserRepositoryMockGet{mock: m}
        m.GetMock.callArgs = []*UserRepositoryMockGetParams{}

        m.UpdateMock = mUserRepositoryMockUpdate{mock: m}
        m.UpdateMock.callArgs = []*UserRepositoryMockUpdateParams{}

        t.Cleanup(m.MinimockFinish)

        return m</span>
}

type mUserRepositoryMockCreate struct {
        optional           bool
        mock               *UserRepositoryMock
        defaultExpectation *UserRepositoryMockCreateExpectation
        expectations       []*UserRepositoryMockCreateExpectation

        callArgs []*UserRepositoryMockCreateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// UserRepositoryMockCreateExpectation specifies expectation struct of the UserRepository.Create
type UserRepositoryMockCreateExpectation struct {
        mock               *UserRepositoryMock
        params             *UserRepositoryMockCreateParams
        paramPtrs          *UserRepositoryMockCreateParamPtrs
        expectationOrigins UserRepositoryMockCreateExpectationOrigins
        results            *UserRepositoryMockCreateResults
        returnOrigin       string
        Counter            uint64
}

// UserRepositoryMockCreateParams contains parameters of the UserRepository.Create
type UserRepositoryMockCreateParams struct {
        ctx        context.Context
        createUser *model.CreateUserData
}

// UserRepositoryMockCreateParamPtrs contains pointers to parameters of the UserRepository.Create
type UserRepositoryMockCreateParamPtrs struct {
        ctx        *context.Context
        createUser **model.CreateUserData
}

// UserRepositoryMockCreateResults contains results of the UserRepository.Create
type UserRepositoryMockCreateResults struct {
        i1  int64
        err error
}

// UserRepositoryMockCreateOrigins contains origins of expectations of the UserRepository.Create
type UserRepositoryMockCreateExpectationOrigins struct {
        origin           string
        originCtx        string
        originCreateUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mUserRepositoryMockCreate) Optional() *mUserRepositoryMockCreate <span class="cov0" title="0">{
        mmCreate.optional = true
        return mmCreate
}</span>

// Expect sets up expected params for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Expect(ctx context.Context, createUser *model.CreateUserData) *mUserRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;UserRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmCreate.defaultExpectation.params = &amp;UserRepositoryMockCreateParams{ctx, createUser}
        mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmCreate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmCreate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmCreate</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;UserRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;UserRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmCreate</span>
}

// ExpectCreateUserParam2 sets up expected param createUser for UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) ExpectCreateUserParam2(createUser *model.CreateUserData) *mUserRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;UserRepositoryMockCreateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation.paramPtrs = &amp;UserRepositoryMockCreateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.paramPtrs.createUser = &amp;createUser
        mmCreate.defaultExpectation.expectationOrigins.originCreateUser = minimock.CallerInfo(1)

        return mmCreate</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Inspect(f func(ctx context.Context, createUser *model.CreateUserData)) *mUserRepositoryMockCreate <span class="cov0" title="0">{
        if mmCreate.mock.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Create")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.inspectFuncCreate = f

        return mmCreate</span>
}

// Return sets up results that will be returned by UserRepository.Create
func (mmCreate *mUserRepositoryMockCreate) Return(i1 int64, err error) *UserRepositoryMock <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmCreate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmCreate.defaultExpectation = &amp;UserRepositoryMockCreateExpectation{mock: mmCreate.mock}
        }</span>
        <span class="cov0" title="0">mmCreate.defaultExpectation.results = &amp;UserRepositoryMockCreateResults{i1, err}
        mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// Set uses given function f to mock the UserRepository.Create method
func (mmCreate *mUserRepositoryMockCreate) Set(f func(ctx context.Context, createUser *model.CreateUserData) (i1 int64, err error)) *UserRepositoryMock <span class="cov0" title="0">{
        if mmCreate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Create method")
        }</span>

        <span class="cov0" title="0">if len(mmCreate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Create method")
        }</span>

        <span class="cov0" title="0">mmCreate.mock.funcCreate = f
        mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
        return mmCreate.mock</span>
}

// When sets expectation for the UserRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mUserRepositoryMockCreate) When(ctx context.Context, createUser *model.CreateUserData) *UserRepositoryMockCreateExpectation <span class="cov0" title="0">{
        if mmCreate.mock.funcCreate != nil </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("UserRepositoryMock.Create mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepositoryMockCreateExpectation{
                mock:               mmCreate.mock,
                params:             &amp;UserRepositoryMockCreateParams{ctx, createUser},
                expectationOrigins: UserRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmCreate.expectations = append(mmCreate.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepository.Create return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockCreateExpectation) Then(i1 int64, err error) *UserRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;UserRepositoryMockCreateResults{i1, err}
        return e.mock
}</span>

// Times sets number of times UserRepository.Create should be invoked
func (mmCreate *mUserRepositoryMockCreate) Times(n uint64) *mUserRepositoryMockCreate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmCreate.mock.t.Fatalf("Times of UserRepositoryMock.Create mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmCreate.expectedInvocations, n)
        mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmCreate</span>
}

func (mmCreate *mUserRepositoryMockCreate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmCreate.expectations) == 0 &amp;&amp; mmCreate.defaultExpectation == nil &amp;&amp; mmCreate.mock.funcCreate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmCreate.mock.afterCreateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmCreate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Create implements mm_repository.UserRepository
func (mmCreate *UserRepositoryMock) Create(ctx context.Context, createUser *model.CreateUserData) (i1 int64, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmCreate.beforeCreateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmCreate.afterCreateCounter, 1)

        mmCreate.t.Helper()

        if mmCreate.inspectFuncCreate != nil </span><span class="cov0" title="0">{
                mmCreate.inspectFuncCreate(ctx, createUser)
        }</span>

        <span class="cov0" title="0">mm_params := UserRepositoryMockCreateParams{ctx, createUser}

        // Record call args
        mmCreate.CreateMock.mutex.Lock()
        mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &amp;mm_params)
        mmCreate.CreateMock.mutex.Unlock()

        for _, e := range mmCreate.CreateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.i1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmCreate.CreateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmCreate.CreateMock.defaultExpectation.Counter, 1)
                mm_want := mmCreate.CreateMock.defaultExpectation.params
                mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

                mm_got := UserRepositoryMockCreateParams{ctx, createUser}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.createUser != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.createUser, mm_got.createUser) </span><span class="cov0" title="0">{
                                mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameter createUser, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCreateUser, *mm_want_ptrs.createUser, mm_got.createUser, minimock.Diff(*mm_want_ptrs.createUser, mm_got.createUser))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmCreate.t.Errorf("UserRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmCreate.CreateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmCreate.t.Fatal("No results are set for the UserRepositoryMock.Create")
                }</span>
                <span class="cov0" title="0">return (*mm_results).i1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmCreate.funcCreate != nil </span><span class="cov0" title="0">{
                return mmCreate.funcCreate(ctx, createUser)
        }</span>
        <span class="cov0" title="0">mmCreate.t.Fatalf("Unexpected call to UserRepositoryMock.Create. %v %v", ctx, createUser)
        return</span>
}

// CreateAfterCounter returns a count of finished UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.afterCreateCounter)
}</span>

// CreateBeforeCounter returns a count of UserRepositoryMock.Create invocations
func (mmCreate *UserRepositoryMock) CreateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmCreate.beforeCreateCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mUserRepositoryMockCreate) Calls() []*UserRepositoryMockCreateParams <span class="cov0" title="0">{
        mmCreate.mutex.RLock()

        argCopy := make([]*UserRepositoryMockCreateParams, len(mmCreate.callArgs))
        copy(argCopy, mmCreate.callArgs)

        mmCreate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockCreateDone() bool <span class="cov0" title="0">{
        if m.CreateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.CreateMock.invocationsDone()</span>
}

// MinimockCreateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockCreateInspect() <span class="cov0" title="0">{
        for _, e := range m.CreateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterCreateCounter := mm_atomic.LoadUint64(&amp;m.afterCreateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.CreateMock.defaultExpectation != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.CreateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcCreate != nil &amp;&amp; afterCreateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to UserRepositoryMock.Create at\n%s", m.funcCreateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.CreateMock.invocationsDone() &amp;&amp; afterCreateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepositoryMock.Create at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
        }</span>
}

type mUserRepositoryMockDelete struct {
        optional           bool
        mock               *UserRepositoryMock
        defaultExpectation *UserRepositoryMockDeleteExpectation
        expectations       []*UserRepositoryMockDeleteExpectation

        callArgs []*UserRepositoryMockDeleteParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// UserRepositoryMockDeleteExpectation specifies expectation struct of the UserRepository.Delete
type UserRepositoryMockDeleteExpectation struct {
        mock               *UserRepositoryMock
        params             *UserRepositoryMockDeleteParams
        paramPtrs          *UserRepositoryMockDeleteParamPtrs
        expectationOrigins UserRepositoryMockDeleteExpectationOrigins
        results            *UserRepositoryMockDeleteResults
        returnOrigin       string
        Counter            uint64
}

// UserRepositoryMockDeleteParams contains parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParams struct {
        ctx context.Context
        id  int64
}

// UserRepositoryMockDeleteParamPtrs contains pointers to parameters of the UserRepository.Delete
type UserRepositoryMockDeleteParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// UserRepositoryMockDeleteResults contains results of the UserRepository.Delete
type UserRepositoryMockDeleteResults struct {
        err error
}

// UserRepositoryMockDeleteOrigins contains origins of expectations of the UserRepository.Delete
type UserRepositoryMockDeleteExpectationOrigins struct {
        origin    string
        originCtx string
        originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mUserRepositoryMockDelete) Optional() *mUserRepositoryMockDelete <span class="cov0" title="0">{
        mmDelete.optional = true
        return mmDelete
}</span>

// Expect sets up expected params for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Expect(ctx context.Context, id int64) *mUserRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;UserRepositoryMockDeleteExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmDelete.defaultExpectation.params = &amp;UserRepositoryMockDeleteParams{ctx, id}
        mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmDelete.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmDelete.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmDelete</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;UserRepositoryMockDeleteExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation.paramPtrs = &amp;UserRepositoryMockDeleteParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDelete.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmDelete</span>
}

// ExpectIdParam2 sets up expected param id for UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) ExpectIdParam2(id int64) *mUserRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;UserRepositoryMockDeleteExpectation{}
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation.paramPtrs = &amp;UserRepositoryMockDeleteParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmDelete.defaultExpectation.paramPtrs.id = &amp;id
        mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmDelete</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockDelete <span class="cov0" title="0">{
        if mmDelete.mock.inspectFuncDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Delete")
        }</span>

        <span class="cov0" title="0">mmDelete.mock.inspectFuncDelete = f

        return mmDelete</span>
}

// Return sets up results that will be returned by UserRepository.Delete
func (mmDelete *mUserRepositoryMockDelete) Return(err error) *UserRepositoryMock <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmDelete.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmDelete.defaultExpectation = &amp;UserRepositoryMockDeleteExpectation{mock: mmDelete.mock}
        }</span>
        <span class="cov0" title="0">mmDelete.defaultExpectation.results = &amp;UserRepositoryMockDeleteResults{err}
        mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmDelete.mock</span>
}

// Set uses given function f to mock the UserRepository.Delete method
func (mmDelete *mUserRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (err error)) *UserRepositoryMock <span class="cov0" title="0">{
        if mmDelete.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Default expectation is already set for the UserRepository.Delete method")
        }</span>

        <span class="cov0" title="0">if len(mmDelete.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Some expectations are already set for the UserRepository.Delete method")
        }</span>

        <span class="cov0" title="0">mmDelete.mock.funcDelete = f
        mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
        return mmDelete.mock</span>
}

// When sets expectation for the UserRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mUserRepositoryMockDelete) When(ctx context.Context, id int64) *UserRepositoryMockDeleteExpectation <span class="cov0" title="0">{
        if mmDelete.mock.funcDelete != nil </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("UserRepositoryMock.Delete mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepositoryMockDeleteExpectation{
                mock:               mmDelete.mock,
                params:             &amp;UserRepositoryMockDeleteParams{ctx, id},
                expectationOrigins: UserRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmDelete.expectations = append(mmDelete.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepository.Delete return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockDeleteExpectation) Then(err error) *UserRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;UserRepositoryMockDeleteResults{err}
        return e.mock
}</span>

// Times sets number of times UserRepository.Delete should be invoked
func (mmDelete *mUserRepositoryMockDelete) Times(n uint64) *mUserRepositoryMockDelete <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmDelete.mock.t.Fatalf("Times of UserRepositoryMock.Delete mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmDelete.expectedInvocations, n)
        mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmDelete</span>
}

func (mmDelete *mUserRepositoryMockDelete) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmDelete.expectations) == 0 &amp;&amp; mmDelete.defaultExpectation == nil &amp;&amp; mmDelete.mock.funcDelete == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmDelete.mock.afterDeleteCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmDelete.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Delete implements mm_repository.UserRepository
func (mmDelete *UserRepositoryMock) Delete(ctx context.Context, id int64) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmDelete.beforeDeleteCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmDelete.afterDeleteCounter, 1)

        mmDelete.t.Helper()

        if mmDelete.inspectFuncDelete != nil </span><span class="cov0" title="0">{
                mmDelete.inspectFuncDelete(ctx, id)
        }</span>

        <span class="cov0" title="0">mm_params := UserRepositoryMockDeleteParams{ctx, id}

        // Record call args
        mmDelete.DeleteMock.mutex.Lock()
        mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &amp;mm_params)
        mmDelete.DeleteMock.mutex.Unlock()

        for _, e := range mmDelete.DeleteMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmDelete.DeleteMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmDelete.DeleteMock.defaultExpectation.Counter, 1)
                mm_want := mmDelete.DeleteMock.defaultExpectation.params
                mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

                mm_got := UserRepositoryMockDeleteParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmDelete.t.Errorf("UserRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmDelete.DeleteMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmDelete.t.Fatal("No results are set for the UserRepositoryMock.Delete")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmDelete.funcDelete != nil </span><span class="cov0" title="0">{
                return mmDelete.funcDelete(ctx, id)
        }</span>
        <span class="cov0" title="0">mmDelete.t.Fatalf("Unexpected call to UserRepositoryMock.Delete. %v %v", ctx, id)
        return</span>
}

// DeleteAfterCounter returns a count of finished UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDelete.afterDeleteCounter)
}</span>

// DeleteBeforeCounter returns a count of UserRepositoryMock.Delete invocations
func (mmDelete *UserRepositoryMock) DeleteBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmDelete.beforeDeleteCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mUserRepositoryMockDelete) Calls() []*UserRepositoryMockDeleteParams <span class="cov0" title="0">{
        mmDelete.mutex.RLock()

        argCopy := make([]*UserRepositoryMockDeleteParams, len(mmDelete.callArgs))
        copy(argCopy, mmDelete.callArgs)

        mmDelete.mutex.RUnlock()

        return argCopy
}</span>

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockDeleteDone() bool <span class="cov0" title="0">{
        if m.DeleteMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.DeleteMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.DeleteMock.invocationsDone()</span>
}

// MinimockDeleteInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockDeleteInspect() <span class="cov0" title="0">{
        for _, e := range m.DeleteMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterDeleteCounter := mm_atomic.LoadUint64(&amp;m.afterDeleteCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.DeleteMock.defaultExpectation != nil &amp;&amp; afterDeleteCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.DeleteMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcDelete != nil &amp;&amp; afterDeleteCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to UserRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
        }</span>

        <span class="cov0" title="0">if !m.DeleteMock.invocationsDone() &amp;&amp; afterDeleteCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepositoryMock.Delete at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
        }</span>
}

type mUserRepositoryMockGet struct {
        optional           bool
        mock               *UserRepositoryMock
        defaultExpectation *UserRepositoryMockGetExpectation
        expectations       []*UserRepositoryMockGetExpectation

        callArgs []*UserRepositoryMockGetParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// UserRepositoryMockGetExpectation specifies expectation struct of the UserRepository.Get
type UserRepositoryMockGetExpectation struct {
        mock               *UserRepositoryMock
        params             *UserRepositoryMockGetParams
        paramPtrs          *UserRepositoryMockGetParamPtrs
        expectationOrigins UserRepositoryMockGetExpectationOrigins
        results            *UserRepositoryMockGetResults
        returnOrigin       string
        Counter            uint64
}

// UserRepositoryMockGetParams contains parameters of the UserRepository.Get
type UserRepositoryMockGetParams struct {
        ctx context.Context
        id  int64
}

// UserRepositoryMockGetParamPtrs contains pointers to parameters of the UserRepository.Get
type UserRepositoryMockGetParamPtrs struct {
        ctx *context.Context
        id  *int64
}

// UserRepositoryMockGetResults contains results of the UserRepository.Get
type UserRepositoryMockGetResults struct {
        up1 *model.User
        err error
}

// UserRepositoryMockGetOrigins contains origins of expectations of the UserRepository.Get
type UserRepositoryMockGetExpectationOrigins struct {
        origin    string
        originCtx string
        originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mUserRepositoryMockGet) Optional() *mUserRepositoryMockGet <span class="cov0" title="0">{
        mmGet.optional = true
        return mmGet
}</span>

// Expect sets up expected params for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Expect(ctx context.Context, id int64) *mUserRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;UserRepositoryMockGetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmGet.defaultExpectation.params = &amp;UserRepositoryMockGetParams{ctx, id}
        mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmGet.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmGet.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmGet</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;UserRepositoryMockGetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation.paramPtrs = &amp;UserRepositoryMockGetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGet.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmGet</span>
}

// ExpectIdParam2 sets up expected param id for UserRepository.Get
func (mmGet *mUserRepositoryMockGet) ExpectIdParam2(id int64) *mUserRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;UserRepositoryMockGetExpectation{}
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation.paramPtrs = &amp;UserRepositoryMockGetParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmGet.defaultExpectation.paramPtrs.id = &amp;id
        mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmGet</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryMockGet <span class="cov0" title="0">{
        if mmGet.mock.inspectFuncGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Get")
        }</span>

        <span class="cov0" title="0">mmGet.mock.inspectFuncGet = f

        return mmGet</span>
}

// Return sets up results that will be returned by UserRepository.Get
func (mmGet *mUserRepositoryMockGet) Return(up1 *model.User, err error) *UserRepositoryMock <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmGet.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmGet.defaultExpectation = &amp;UserRepositoryMockGetExpectation{mock: mmGet.mock}
        }</span>
        <span class="cov0" title="0">mmGet.defaultExpectation.results = &amp;UserRepositoryMockGetResults{up1, err}
        mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmGet.mock</span>
}

// Set uses given function f to mock the UserRepository.Get method
func (mmGet *mUserRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *UserRepositoryMock <span class="cov0" title="0">{
        if mmGet.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Default expectation is already set for the UserRepository.Get method")
        }</span>

        <span class="cov0" title="0">if len(mmGet.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Some expectations are already set for the UserRepository.Get method")
        }</span>

        <span class="cov0" title="0">mmGet.mock.funcGet = f
        mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
        return mmGet.mock</span>
}

// When sets expectation for the UserRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mUserRepositoryMockGet) When(ctx context.Context, id int64) *UserRepositoryMockGetExpectation <span class="cov0" title="0">{
        if mmGet.mock.funcGet != nil </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("UserRepositoryMock.Get mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepositoryMockGetExpectation{
                mock:               mmGet.mock,
                params:             &amp;UserRepositoryMockGetParams{ctx, id},
                expectationOrigins: UserRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmGet.expectations = append(mmGet.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepository.Get return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockGetExpectation) Then(up1 *model.User, err error) *UserRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;UserRepositoryMockGetResults{up1, err}
        return e.mock
}</span>

// Times sets number of times UserRepository.Get should be invoked
func (mmGet *mUserRepositoryMockGet) Times(n uint64) *mUserRepositoryMockGet <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmGet.mock.t.Fatalf("Times of UserRepositoryMock.Get mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmGet.expectedInvocations, n)
        mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmGet</span>
}

func (mmGet *mUserRepositoryMockGet) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmGet.expectations) == 0 &amp;&amp; mmGet.defaultExpectation == nil &amp;&amp; mmGet.mock.funcGet == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmGet.mock.afterGetCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmGet.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Get implements mm_repository.UserRepository
func (mmGet *UserRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.User, err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmGet.beforeGetCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmGet.afterGetCounter, 1)

        mmGet.t.Helper()

        if mmGet.inspectFuncGet != nil </span><span class="cov0" title="0">{
                mmGet.inspectFuncGet(ctx, id)
        }</span>

        <span class="cov0" title="0">mm_params := UserRepositoryMockGetParams{ctx, id}

        // Record call args
        mmGet.GetMock.mutex.Lock()
        mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &amp;mm_params)
        mmGet.GetMock.mutex.Unlock()

        for _, e := range mmGet.GetMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.up1, e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmGet.GetMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmGet.GetMock.defaultExpectation.Counter, 1)
                mm_want := mmGet.GetMock.defaultExpectation.params
                mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

                mm_got := UserRepositoryMockGetParams{ctx, id}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmGet.t.Errorf("UserRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmGet.GetMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmGet.t.Fatal("No results are set for the UserRepositoryMock.Get")
                }</span>
                <span class="cov0" title="0">return (*mm_results).up1, (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmGet.funcGet != nil </span><span class="cov0" title="0">{
                return mmGet.funcGet(ctx, id)
        }</span>
        <span class="cov0" title="0">mmGet.t.Fatalf("Unexpected call to UserRepositoryMock.Get. %v %v", ctx, id)
        return</span>
}

// GetAfterCounter returns a count of finished UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGet.afterGetCounter)
}</span>

// GetBeforeCounter returns a count of UserRepositoryMock.Get invocations
func (mmGet *UserRepositoryMock) GetBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmGet.beforeGetCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mUserRepositoryMockGet) Calls() []*UserRepositoryMockGetParams <span class="cov0" title="0">{
        mmGet.mutex.RLock()

        argCopy := make([]*UserRepositoryMockGetParams, len(mmGet.callArgs))
        copy(argCopy, mmGet.callArgs)

        mmGet.mutex.RUnlock()

        return argCopy
}</span>

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockGetDone() bool <span class="cov0" title="0">{
        if m.GetMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.GetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.GetMock.invocationsDone()</span>
}

// MinimockGetInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockGetInspect() <span class="cov0" title="0">{
        for _, e := range m.GetMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterGetCounter := mm_atomic.LoadUint64(&amp;m.afterGetCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.GetMock.defaultExpectation != nil &amp;&amp; afterGetCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.GetMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcGet != nil &amp;&amp; afterGetCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to UserRepositoryMock.Get at\n%s", m.funcGetOrigin)
        }</span>

        <span class="cov0" title="0">if !m.GetMock.invocationsDone() &amp;&amp; afterGetCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepositoryMock.Get at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
        }</span>
}

type mUserRepositoryMockUpdate struct {
        optional           bool
        mock               *UserRepositoryMock
        defaultExpectation *UserRepositoryMockUpdateExpectation
        expectations       []*UserRepositoryMockUpdateExpectation

        callArgs []*UserRepositoryMockUpdateParams
        mutex    sync.RWMutex

        expectedInvocations       uint64
        expectedInvocationsOrigin string
}

// UserRepositoryMockUpdateExpectation specifies expectation struct of the UserRepository.Update
type UserRepositoryMockUpdateExpectation struct {
        mock               *UserRepositoryMock
        params             *UserRepositoryMockUpdateParams
        paramPtrs          *UserRepositoryMockUpdateParamPtrs
        expectationOrigins UserRepositoryMockUpdateExpectationOrigins
        results            *UserRepositoryMockUpdateResults
        returnOrigin       string
        Counter            uint64
}

// UserRepositoryMockUpdateParams contains parameters of the UserRepository.Update
type UserRepositoryMockUpdateParams struct {
        ctx        context.Context
        id         int64
        updateUser *model.UpdateUserData
}

// UserRepositoryMockUpdateParamPtrs contains pointers to parameters of the UserRepository.Update
type UserRepositoryMockUpdateParamPtrs struct {
        ctx        *context.Context
        id         *int64
        updateUser **model.UpdateUserData
}

// UserRepositoryMockUpdateResults contains results of the UserRepository.Update
type UserRepositoryMockUpdateResults struct {
        err error
}

// UserRepositoryMockUpdateOrigins contains origins of expectations of the UserRepository.Update
type UserRepositoryMockUpdateExpectationOrigins struct {
        origin           string
        originCtx        string
        originId         string
        originUpdateUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mUserRepositoryMockUpdate) Optional() *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        mmUpdate.optional = true
        return mmUpdate
}</span>

// Expect sets up expected params for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Expect(ctx context.Context, id int64, updateUser *model.UpdateUserData) *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;UserRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by ExpectParams functions")
        }</span>

        <span class="cov0" title="0">mmUpdate.defaultExpectation.params = &amp;UserRepositoryMockUpdateParams{ctx, id, updateUser}
        mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
        for _, e := range mmUpdate.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) </span><span class="cov0" title="0">{
                        mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
                }</span>
        }

        <span class="cov0" title="0">return mmUpdate</span>
}

// ExpectCtxParam1 sets up expected param ctx for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;UserRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;UserRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.ctx = &amp;ctx
        mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectIdParam2 sets up expected param id for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectIdParam2(id int64) *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;UserRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;UserRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.id = &amp;id
        mmUpdate.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// ExpectUpdateUserParam3 sets up expected param updateUser for UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) ExpectUpdateUserParam3(updateUser *model.UpdateUserData) *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;UserRepositoryMockUpdateExpectation{}
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.params != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Expect")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation.paramPtrs == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation.paramPtrs = &amp;UserRepositoryMockUpdateParamPtrs{}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.paramPtrs.updateUser = &amp;updateUser
        mmUpdate.defaultExpectation.expectationOrigins.originUpdateUser = minimock.CallerInfo(1)

        return mmUpdate</span>
}

// Inspect accepts an inspector function that has same arguments as the UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Inspect(f func(ctx context.Context, id int64, updateUser *model.UpdateUserData)) *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        if mmUpdate.mock.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Inspect function is already set for UserRepositoryMock.Update")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.inspectFuncUpdate = f

        return mmUpdate</span>
}

// Return sets up results that will be returned by UserRepository.Update
func (mmUpdate *mUserRepositoryMockUpdate) Return(err error) *UserRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">if mmUpdate.defaultExpectation == nil </span><span class="cov0" title="0">{
                mmUpdate.defaultExpectation = &amp;UserRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
        }</span>
        <span class="cov0" title="0">mmUpdate.defaultExpectation.results = &amp;UserRepositoryMockUpdateResults{err}
        mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// Set uses given function f to mock the UserRepository.Update method
func (mmUpdate *mUserRepositoryMockUpdate) Set(f func(ctx context.Context, id int64, updateUser *model.UpdateUserData) (err error)) *UserRepositoryMock <span class="cov0" title="0">{
        if mmUpdate.defaultExpectation != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Default expectation is already set for the UserRepository.Update method")
        }</span>

        <span class="cov0" title="0">if len(mmUpdate.expectations) &gt; 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Some expectations are already set for the UserRepository.Update method")
        }</span>

        <span class="cov0" title="0">mmUpdate.mock.funcUpdate = f
        mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
        return mmUpdate.mock</span>
}

// When sets expectation for the UserRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mUserRepositoryMockUpdate) When(ctx context.Context, id int64, updateUser *model.UpdateUserData) *UserRepositoryMockUpdateExpectation <span class="cov0" title="0">{
        if mmUpdate.mock.funcUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("UserRepositoryMock.Update mock is already set by Set")
        }</span>

        <span class="cov0" title="0">expectation := &amp;UserRepositoryMockUpdateExpectation{
                mock:               mmUpdate.mock,
                params:             &amp;UserRepositoryMockUpdateParams{ctx, id, updateUser},
                expectationOrigins: UserRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
        }
        mmUpdate.expectations = append(mmUpdate.expectations, expectation)
        return expectation</span>
}

// Then sets up UserRepository.Update return parameters for the expectation previously defined by the When method
func (e *UserRepositoryMockUpdateExpectation) Then(err error) *UserRepositoryMock <span class="cov0" title="0">{
        e.results = &amp;UserRepositoryMockUpdateResults{err}
        return e.mock
}</span>

// Times sets number of times UserRepository.Update should be invoked
func (mmUpdate *mUserRepositoryMockUpdate) Times(n uint64) *mUserRepositoryMockUpdate <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                mmUpdate.mock.t.Fatalf("Times of UserRepositoryMock.Update mock can not be zero")
        }</span>
        <span class="cov0" title="0">mm_atomic.StoreUint64(&amp;mmUpdate.expectedInvocations, n)
        mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
        return mmUpdate</span>
}

func (mmUpdate *mUserRepositoryMockUpdate) invocationsDone() bool <span class="cov0" title="0">{
        if len(mmUpdate.expectations) == 0 &amp;&amp; mmUpdate.defaultExpectation == nil &amp;&amp; mmUpdate.mock.funcUpdate == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">totalInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.mock.afterUpdateCounter)
        expectedInvocations := mm_atomic.LoadUint64(&amp;mmUpdate.expectedInvocations)

        return totalInvocations &gt; 0 &amp;&amp; (expectedInvocations == 0 || expectedInvocations == totalInvocations)</span>
}

// Update implements mm_repository.UserRepository
func (mmUpdate *UserRepositoryMock) Update(ctx context.Context, id int64, updateUser *model.UpdateUserData) (err error) <span class="cov0" title="0">{
        mm_atomic.AddUint64(&amp;mmUpdate.beforeUpdateCounter, 1)
        defer mm_atomic.AddUint64(&amp;mmUpdate.afterUpdateCounter, 1)

        mmUpdate.t.Helper()

        if mmUpdate.inspectFuncUpdate != nil </span><span class="cov0" title="0">{
                mmUpdate.inspectFuncUpdate(ctx, id, updateUser)
        }</span>

        <span class="cov0" title="0">mm_params := UserRepositoryMockUpdateParams{ctx, id, updateUser}

        // Record call args
        mmUpdate.UpdateMock.mutex.Lock()
        mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &amp;mm_params)
        mmUpdate.UpdateMock.mutex.Unlock()

        for _, e := range mmUpdate.UpdateMock.expectations </span><span class="cov0" title="0">{
                if minimock.Equal(*e.params, mm_params) </span><span class="cov0" title="0">{
                        mm_atomic.AddUint64(&amp;e.Counter, 1)
                        return e.results.err
                }</span>
        }

        <span class="cov0" title="0">if mmUpdate.UpdateMock.defaultExpectation != nil </span><span class="cov0" title="0">{
                mm_atomic.AddUint64(&amp;mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
                mm_want := mmUpdate.UpdateMock.defaultExpectation.params
                mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

                mm_got := UserRepositoryMockUpdateParams{ctx, id, updateUser}

                if mm_want_ptrs != nil </span><span class="cov0" title="0">{

                        if mm_want_ptrs.ctx != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.id != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.id, mm_got.id) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
                        }</span>

                        <span class="cov0" title="0">if mm_want_ptrs.updateUser != nil &amp;&amp; !minimock.Equal(*mm_want_ptrs.updateUser, mm_got.updateUser) </span><span class="cov0" title="0">{
                                mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameter updateUser, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                        mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdateUser, *mm_want_ptrs.updateUser, mm_got.updateUser, minimock.Diff(*mm_want_ptrs.updateUser, mm_got.updateUser))
                        }</span>

                } else<span class="cov0" title="0"> if mm_want != nil &amp;&amp; !minimock.Equal(*mm_want, mm_got) </span><span class="cov0" title="0">{
                        mmUpdate.t.Errorf("UserRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
                                mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
                }</span>

                <span class="cov0" title="0">mm_results := mmUpdate.UpdateMock.defaultExpectation.results
                if mm_results == nil </span><span class="cov0" title="0">{
                        mmUpdate.t.Fatal("No results are set for the UserRepositoryMock.Update")
                }</span>
                <span class="cov0" title="0">return (*mm_results).err</span>
        }
        <span class="cov0" title="0">if mmUpdate.funcUpdate != nil </span><span class="cov0" title="0">{
                return mmUpdate.funcUpdate(ctx, id, updateUser)
        }</span>
        <span class="cov0" title="0">mmUpdate.t.Fatalf("Unexpected call to UserRepositoryMock.Update. %v %v %v", ctx, id, updateUser)
        return</span>
}

// UpdateAfterCounter returns a count of finished UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateAfterCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.afterUpdateCounter)
}</span>

// UpdateBeforeCounter returns a count of UserRepositoryMock.Update invocations
func (mmUpdate *UserRepositoryMock) UpdateBeforeCounter() uint64 <span class="cov0" title="0">{
        return mm_atomic.LoadUint64(&amp;mmUpdate.beforeUpdateCounter)
}</span>

// Calls returns a list of arguments used in each call to UserRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mUserRepositoryMockUpdate) Calls() []*UserRepositoryMockUpdateParams <span class="cov0" title="0">{
        mmUpdate.mutex.RLock()

        argCopy := make([]*UserRepositoryMockUpdateParams, len(mmUpdate.callArgs))
        copy(argCopy, mmUpdate.callArgs)

        mmUpdate.mutex.RUnlock()

        return argCopy
}</span>

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *UserRepositoryMock) MinimockUpdateDone() bool <span class="cov0" title="0">{
        if m.UpdateMock.optional </span><span class="cov0" title="0">{
                // Optional methods provide '0 or more' call count restriction.
                return true
        }</span>

        <span class="cov0" title="0">for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return m.UpdateMock.invocationsDone()</span>
}

// MinimockUpdateInspect logs each unmet expectation
func (m *UserRepositoryMock) MinimockUpdateInspect() <span class="cov0" title="0">{
        for _, e := range m.UpdateMock.expectations </span><span class="cov0" title="0">{
                if mm_atomic.LoadUint64(&amp;e.Counter) &lt; 1 </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
                }</span>
        }

        <span class="cov0" title="0">afterUpdateCounter := mm_atomic.LoadUint64(&amp;m.afterUpdateCounter)
        // if default expectation was set then invocations count should be greater than zero
        if m.UpdateMock.defaultExpectation != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                if m.UpdateMock.defaultExpectation.params == nil </span><span class="cov0" title="0">{
                        m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
                }</span> else<span class="cov0" title="0"> {
                        m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
                }</span>
        }
        // if func was set then invocations count should be greater than zero
        <span class="cov0" title="0">if m.funcUpdate != nil &amp;&amp; afterUpdateCounter &lt; 1 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected call to UserRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
        }</span>

        <span class="cov0" title="0">if !m.UpdateMock.invocationsDone() &amp;&amp; afterUpdateCounter &gt; 0 </span><span class="cov0" title="0">{
                m.t.Errorf("Expected %d calls to UserRepositoryMock.Update at\n%s but found %d calls",
                        mm_atomic.LoadUint64(&amp;m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
        }</span>
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryMock) MinimockFinish() <span class="cov0" title="0">{
        m.finishOnce.Do(func() </span><span class="cov0" title="0">{
                if !m.minimockDone() </span><span class="cov0" title="0">{
                        m.MinimockCreateInspect()

                        m.MinimockDeleteInspect()

                        m.MinimockGetInspect()

                        m.MinimockUpdateInspect()
                }</span>
        })
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryMock) MinimockWait(timeout mm_time.Duration) <span class="cov0" title="0">{
        timeoutCh := mm_time.After(timeout)
        for </span><span class="cov0" title="0">{
                if m.minimockDone() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">select </span>{
                case &lt;-timeoutCh:<span class="cov0" title="0">
                        m.MinimockFinish()
                        return</span>
                case &lt;-mm_time.After(10 * mm_time.Millisecond):<span class="cov0" title="0"></span>
                }
        }
}

func (m *UserRepositoryMock) minimockDone() bool <span class="cov0" title="0">{
        done := true
        return done &amp;&amp;
                m.MinimockCreateDone() &amp;&amp;
                m.MinimockDeleteDone() &amp;&amp;
                m.MinimockGetDone() &amp;&amp;
                m.MinimockUpdateDone()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package converter

import (
        "auth/internal/model"
        modelRepo "auth/internal/repository/user/model"
)

func ToUserFromRepo(user *modelRepo.User) *model.User <span class="cov0" title="0">{
        return &amp;model.User{
                ID:        user.ID,
                Info:      ToUserInfoFromRepo(user.Info),
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        }
}</span>

func ToUserInfoFromRepo(info modelRepo.UserInfo) model.UserInfo <span class="cov0" title="0">{
        return model.UserInfo{
                Name:  info.Name,
                Email: info.Email,
                Role:  model.Role(info.Role),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package model

import (
        "database/sql"
        "time"
)

type User struct {
        ID        int64        `db:"id"`
        Info      UserInfo     `db:""`
        CreatedAt time.Time    `db:"created_at"`
        UpdatedAt sql.NullTime `db:"updated_at"`
}

type UserInfo struct {
        Name  string `db:"name"`
        Email string `db:"email"`
        Role  Role   `db:"role"`
}

type CreateUserData struct {
        Info            UserInfo `db:""`
        Password        string   `db:"password"`
        PasswordConfirm string   `db:"password"`
}

type Role int32

const (
        RoleUnspecified Role = iota
        RoleUser
        RoleAdmin
)

func (r Role) String() string <span class="cov0" title="0">{
        switch r </span>{
        case RoleUser:<span class="cov0" title="0">
                return "USER"</span>
        case RoleAdmin:<span class="cov0" title="0">
                return "ADMIN"</span>
        default:<span class="cov0" title="0">
                return "UNSPECIFIED"</span>
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package user

import (
        "auth/internal/model"
        "auth/internal/repository"
        repoConverter "auth/internal/repository/user/converter"
        modelRepo "auth/internal/repository/user/model"
        "context"
        "log"
        "time"

        "github.com/makxtr/go-common/pkg/db"

        sq "github.com/Masterminds/squirrel"
)

const (
        tableName = "users"

        idColumn        = "id"
        nameColumn      = "name"
        emailColumn     = "email"
        passColumn      = "password"
        roleColumn      = "role"
        createdAtColumn = "created_at"
        updatedAtColumn = "updated_at"
)

type repo struct {
        db db.Client
}

func NewRepository(db db.Client) repository.UserRepository <span class="cov0" title="0">{
        return &amp;repo{db: db}
}</span>

func (r *repo) Create(ctx context.Context, createUser *model.CreateUserData) (int64, error) <span class="cov0" title="0">{
        builder := sq.Insert(tableName).
                PlaceholderFormat(sq.Dollar).
                Columns("name", "email", "password", "role").
                Values(createUser.Info.Name, createUser.Info.Email, createUser.HashedPassword, int32(createUser.Info.Role)).
                Suffix("RETURNING id")

        query, args, err := builder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to build query: %v", err)
                return 0, repository.ErrQueryBuild
        }</span>

        <span class="cov0" title="0">var userID int64
        err = r.db.DB().QueryRowContext(ctx, db.Query{Name: "user_repository.Create", QueryRaw: query}, args...).Scan(&amp;userID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to create user: %v", err)
                return 0, repository.ErrCreateFailed
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}

func (r *repo) Get(ctx context.Context, id int64) (*model.User, error) <span class="cov0" title="0">{
        builder := sq.Select(idColumn, nameColumn, emailColumn, roleColumn, createdAtColumn, updatedAtColumn).
                PlaceholderFormat(sq.Dollar).
                From(tableName).
                Where(sq.Eq{idColumn: id}).
                Limit(1)

        query, args, err := builder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, repository.ErrQueryBuild
        }</span>

        <span class="cov0" title="0">q := db.Query{
                Name:     "user_repository.Get",
                QueryRaw: query,
        }

        var user modelRepo.User
        err = r.db.DB().QueryRowContext(ctx, q, args...).Scan(&amp;user.ID, &amp;user.Info.Name, &amp;user.Info.Email, &amp;user.Info.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return repoConverter.ToUserFromRepo(&amp;user), nil</span>
}

func (r *repo) Update(ctx context.Context, id int64, updateUser *model.UpdateUserData) error <span class="cov0" title="0">{
        builder := sq.Update(tableName).
                PlaceholderFormat(sq.Dollar).
                Set(updatedAtColumn, time.Now()).
                Where(sq.Eq{idColumn: id})

        if updateUser.Name != nil </span><span class="cov0" title="0">{
                builder = builder.Set(nameColumn, updateUser.Name)
        }</span>

        <span class="cov0" title="0">if updateUser.Email != nil </span><span class="cov0" title="0">{
                builder = builder.Set(emailColumn, updateUser.Email)
        }</span>

        <span class="cov0" title="0">query, args, err := builder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to build query: %v", err)
                return repository.ErrQueryBuild
        }</span>

        <span class="cov0" title="0">res, err := r.db.DB().ExecContext(ctx, db.Query{Name: "user_repository.Update", QueryRaw: query}, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to update user: %v", err)
                return repository.ErrUpdateFailed
        }</span>

        <span class="cov0" title="0">if res.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *repo) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        builder := sq.Delete(tableName).
                PlaceholderFormat(sq.Dollar).
                Where(sq.Eq{idColumn: id})

        query, args, err := builder.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to build query: %v", err)
                return repository.ErrQueryBuild
        }</span>

        <span class="cov0" title="0">res, err := r.db.DB().ExecContext(ctx, db.Query{Name: "user_repository.Delete", QueryRaw: query}, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to delete user: %v", err)
                return repository.ErrDeleteFailed
        }</span>

        <span class="cov0" title="0">if res.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package user

import (
        "auth/internal/model"
        "context"
        "log"

        logModel "github.com/makxtr/go-common/pkg/logger/model"

        "golang.org/x/crypto/bcrypt"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

func (s *serv) Create(ctx context.Context, command *model.CreateUserCommand) (int64, error) <span class="cov0" title="0">{
        var id int64

        if err := command.Validate(); err != nil </span><span class="cov0" title="0">{
                return 0, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(command.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to hash password: %v", err)
                return 0, status.Error(codes.Internal, "failed to hash password")
        }</span>

        <span class="cov0" title="0">createData := &amp;model.CreateUserData{
                Info:           command.Info,
                HashedPassword: string(hashedPassword),
        }

        err = s.txManager.ReadCommitted(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                var errTx error
                id, errTx = s.userRepository.Create(ctx, createData)
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">_, errTx = s.userRepository.Get(ctx, id)
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">errTx = s.logRepository.Log(ctx, &amp;logModel.Log{
                        Action:   "user_created",
                        EntityID: id,
                })
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package user

import (
        "context"

        logModel "github.com/makxtr/go-common/pkg/logger/model"
)

func (s *serv) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        err := s.txManager.ReadCommitted(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                errTx := s.userRepository.Delete(ctx, id)
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">errTx = s.logRepository.Log(ctx, &amp;logModel.Log{
                        Action:   "user_deleted",
                        EntityID: id,
                })
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package user

import (
        "auth/internal/model"
        "context"
)

func (s *serv) Get(ctx context.Context, id int64) (*model.User, error) <span class="cov0" title="0">{
        note, err := s.userRepository.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package user

import (
        "auth/internal/repository"
        "auth/internal/service"

        "github.com/makxtr/go-common/pkg/db"
)

type serv struct {
        userRepository repository.UserRepository
        logRepository  repository.LogRepository
        txManager      db.TxManager
}

func NewService(
        userRepository repository.UserRepository,
        logRepository repository.LogRepository,
        txManager db.TxManager,
) service.UserService <span class="cov0" title="0">{
        return &amp;serv{
                userRepository: userRepository,
                logRepository:  logRepository,
                txManager:      txManager,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package user

import (
        "auth/internal/model"
        "context"

        logModel "github.com/makxtr/go-common/pkg/logger/model"
)

func (s *serv) Update(ctx context.Context, id int64, updateUser *model.UpdateUserData) error <span class="cov0" title="0">{
        err := s.txManager.ReadCommitted(ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                errTx := s.userRepository.Update(ctx, id, updateUser)
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">errTx = s.logRepository.Log(ctx, &amp;logModel.Log{
                        Action:   "user_updated",
                        EntityID: id,
                })
                if errTx != nil </span><span class="cov0" title="0">{
                        return errTx
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v3.12.4
// source: user.proto

package user_v1

import (
        empty "github.com/golang/protobuf/ptypes/empty"
        timestamp "github.com/golang/protobuf/ptypes/timestamp"
        wrappers "github.com/golang/protobuf/ptypes/wrappers"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Role int32

const (
        Role_ROLE_UNSPECIFIED Role = 0
        Role_ROLE_USER        Role = 1
        Role_ROLE_ADMIN       Role = 2
)

// Enum value maps for Role.
var (
        Role_name = map[int32]string{
                0: "ROLE_UNSPECIFIED",
                1: "ROLE_USER",
                2: "ROLE_ADMIN",
        }
        Role_value = map[string]int32{
                "ROLE_UNSPECIFIED": 0,
                "ROLE_USER":        1,
                "ROLE_ADMIN":       2,
        }
)

func (x Role) Enum() *Role <span class="cov0" title="0">{
        p := new(Role)
        *p = x
        return p
}</span>

func (x Role) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Role) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_user_proto_enumTypes[0].Descriptor()
}</span>

func (Role) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_user_proto_enumTypes[0]
}</span>

func (x Role) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Role.Descriptor instead.
func (Role) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{0}
}</span>

type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id        int64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Name      string               `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Email     string               `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        Role      Role                 `protobuf:"varint,4,opt,name=role,proto3,enum=user_v1.Role" json:"role,omitempty"`
        CreatedAt *timestamp.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt *timestamp.Timestamp `protobuf:"bytes,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *User) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *User) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetRole() Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return Role_ROLE_UNSPECIFIED</span>
}

func (x *User) GetCreatedAt() *timestamp.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetUpdatedAt() *timestamp.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateUserInfo struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name  *wrappers.StringValue `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Email *wrappers.StringValue `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *UpdateUserInfo) Reset() <span class="cov0" title="0">{
        *x = UpdateUserInfo{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateUserInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserInfo.ProtoReflect.Descriptor instead.
func (*UpdateUserInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *UpdateUserInfo) GetName() *wrappers.StringValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateUserInfo) GetEmail() *wrappers.StringValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name            string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Email           string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Password        string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        PasswordConfirm string `protobuf:"bytes,4,opt,name=password_confirm,json=passwordConfirm,proto3" json:"password_confirm,omitempty"`
        Role            Role   `protobuf:"varint,5,opt,name=role,proto3,enum=user_v1.Role" json:"role,omitempty"`
}

func (x *CreateRequest) Reset() <span class="cov0" title="0">{
        *x = CreateRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateRequest.ProtoReflect.Descriptor instead.
func (*CreateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CreateRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateRequest) GetPasswordConfirm() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PasswordConfirm
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateRequest) GetRole() Role <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return Role_ROLE_UNSPECIFIED</span>
}

type CreateResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *CreateResponse) Reset() <span class="cov0" title="0">{
        *x = CreateResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CreateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateResponse.ProtoReflect.Descriptor instead.
func (*CreateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CreateResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *GetRequest) Reset() <span class="cov0" title="0">{
        *x = GetRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *GetRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        User *User `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
}

func (x *GetResponse) Reset() <span class="cov0" title="0">{
        *x = GetResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id   int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Info *UpdateUserInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (x *UpdateRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateRequest.ProtoReflect.Descriptor instead.
func (*UpdateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{6}
}</span>

func (x *UpdateRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateRequest) GetInfo() *UpdateUserInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Info
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DeleteRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DeleteRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_user_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_user_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_user_proto_rawDescGZIP(), []int{7}
}</span>

func (x *DeleteRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_user_proto protoreflect.FileDescriptor

var file_user_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x75, 0x73,
        0x65, 0x72, 0x5f, 0x76, 0x31, 0x1a, 0x1b, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x73, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0xd9, 0x01, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x21, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x2e, 0x52,
        0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65,
        0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74,
        0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f,
        0x61, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22,
        0x76, 0x0a, 0x0e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66,
        0x6f, 0x12, 0x30, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x32, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0xa3, 0x01, 0x0a, 0x0d, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a,
        0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d,
        0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12,
        0x29, 0x0a, 0x10, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66,
        0x69, 0x72, 0x6d, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x70, 0x61, 0x73, 0x73, 0x77,
        0x6f, 0x72, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x12, 0x21, 0x0a, 0x04, 0x72, 0x6f,
        0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0d, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x76, 0x31, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x52, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x22, 0x20, 0x0a,
        0x0e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x22,
        0x1c, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a,
        0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x22, 0x30, 0x0a,
        0x0b, 0x47, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21, 0x0a, 0x04,
        0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x75, 0x73, 0x65,
        0x72, 0x5f, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22,
        0x4c, 0x0a, 0x0d, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64,
        0x12, 0x2b, 0x0a, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17,
        0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x55,
        0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x04, 0x69, 0x6e, 0x66, 0x6f, 0x22, 0x1f, 0x0a,
        0x0d, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x2a, 0x3b,
        0x0a, 0x04, 0x52, 0x6f, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x55,
        0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0d, 0x0a, 0x09,
        0x52, 0x4f, 0x4c, 0x45, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x52,
        0x4f, 0x4c, 0x45, 0x5f, 0x41, 0x44, 0x4d, 0x49, 0x4e, 0x10, 0x02, 0x32, 0xe9, 0x01, 0x0a, 0x06,
        0x55, 0x73, 0x65, 0x72, 0x56, 0x31, 0x12, 0x39, 0x0a, 0x06, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x12, 0x16, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74,
        0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x30, 0x0a, 0x03, 0x47, 0x65, 0x74, 0x12, 0x13, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x14, 0x2e,
        0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x06, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x16, 0x2e,
        0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x38, 0x0a,
        0x06, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x16, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76,
        0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x42, 0x15, 0x5a, 0x13, 0x70, 0x6b, 0x67, 0x2f, 0x75,
        0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x3b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x76, 0x31, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_user_proto_rawDescOnce sync.Once
        file_user_proto_rawDescData = file_user_proto_rawDesc
)

func file_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_user_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_user_proto_rawDescData</span>
}

var file_user_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_user_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_user_proto_goTypes = []interface{}{
        (Role)(0),                    // 0: user_v1.Role
        (*User)(nil),                 // 1: user_v1.User
        (*UpdateUserInfo)(nil),       // 2: user_v1.UpdateUserInfo
        (*CreateRequest)(nil),        // 3: user_v1.CreateRequest
        (*CreateResponse)(nil),       // 4: user_v1.CreateResponse
        (*GetRequest)(nil),           // 5: user_v1.GetRequest
        (*GetResponse)(nil),          // 6: user_v1.GetResponse
        (*UpdateRequest)(nil),        // 7: user_v1.UpdateRequest
        (*DeleteRequest)(nil),        // 8: user_v1.DeleteRequest
        (*timestamp.Timestamp)(nil),  // 9: google.protobuf.Timestamp
        (*wrappers.StringValue)(nil), // 10: google.protobuf.StringValue
        (*empty.Empty)(nil),          // 11: google.protobuf.Empty
}
var file_user_proto_depIdxs = []int32{
        0,  // 0: user_v1.User.role:type_name -&gt; user_v1.Role
        9,  // 1: user_v1.User.created_at:type_name -&gt; google.protobuf.Timestamp
        9,  // 2: user_v1.User.updated_at:type_name -&gt; google.protobuf.Timestamp
        10, // 3: user_v1.UpdateUserInfo.name:type_name -&gt; google.protobuf.StringValue
        10, // 4: user_v1.UpdateUserInfo.email:type_name -&gt; google.protobuf.StringValue
        0,  // 5: user_v1.CreateRequest.role:type_name -&gt; user_v1.Role
        1,  // 6: user_v1.GetResponse.user:type_name -&gt; user_v1.User
        2,  // 7: user_v1.UpdateRequest.info:type_name -&gt; user_v1.UpdateUserInfo
        3,  // 8: user_v1.UserV1.Create:input_type -&gt; user_v1.CreateRequest
        5,  // 9: user_v1.UserV1.Get:input_type -&gt; user_v1.GetRequest
        7,  // 10: user_v1.UserV1.Update:input_type -&gt; user_v1.UpdateRequest
        8,  // 11: user_v1.UserV1.Delete:input_type -&gt; user_v1.DeleteRequest
        4,  // 12: user_v1.UserV1.Create:output_type -&gt; user_v1.CreateResponse
        6,  // 13: user_v1.UserV1.Get:output_type -&gt; user_v1.GetResponse
        11, // 14: user_v1.UserV1.Update:output_type -&gt; google.protobuf.Empty
        11, // 15: user_v1.UserV1.Delete:output_type -&gt; google.protobuf.Empty
        12, // [12:16] is the sub-list for method output_type
        8,  // [8:12] is the sub-list for method input_type
        8,  // [8:8] is the sub-list for extension type_name
        8,  // [8:8] is the sub-list for extension extendee
        0,  // [0:8] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_user_proto_init() }</span>
func file_user_proto_init() <span class="cov0" title="0">{
        if File_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_user_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*User); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateUserInfo); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CreateResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_user_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_user_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_user_proto_goTypes,
                DependencyIndexes: file_user_proto_depIdxs,
                EnumInfos:         file_user_proto_enumTypes,
                MessageInfos:      file_user_proto_msgTypes,
        }.Build()
        File_user_proto = out.File
        file_user_proto_rawDesc = nil
        file_user_proto_goTypes = nil
        file_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: user.proto

package user_v1

import (
        context "context"
        empty "github.com/golang/protobuf/ptypes/empty"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserV1Client is the client API for UserV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserV1Client interface {
        Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
        Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
        Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*empty.Empty, error)
        Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type userV1Client struct {
        cc grpc.ClientConnInterface
}

func NewUserV1Client(cc grpc.ClientConnInterface) UserV1Client <span class="cov0" title="0">{
        return &amp;userV1Client{cc}
}</span>

func (c *userV1Client) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) <span class="cov0" title="0">{
        out := new(CreateResponse)
        err := c.cc.Invoke(ctx, "/user_v1.UserV1/Create", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userV1Client) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) <span class="cov0" title="0">{
        out := new(GetResponse)
        err := c.cc.Invoke(ctx, "/user_v1.UserV1/Get", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userV1Client) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*empty.Empty, error) <span class="cov0" title="0">{
        out := new(empty.Empty)
        err := c.cc.Invoke(ctx, "/user_v1.UserV1/Update", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userV1Client) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*empty.Empty, error) <span class="cov0" title="0">{
        out := new(empty.Empty)
        err := c.cc.Invoke(ctx, "/user_v1.UserV1/Delete", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserV1Server is the server API for UserV1 service.
// All implementations must embed UnimplementedUserV1Server
// for forward compatibility
type UserV1Server interface {
        Create(context.Context, *CreateRequest) (*CreateResponse, error)
        Get(context.Context, *GetRequest) (*GetResponse, error)
        Update(context.Context, *UpdateRequest) (*empty.Empty, error)
        Delete(context.Context, *DeleteRequest) (*empty.Empty, error)
        mustEmbedUnimplementedUserV1Server()
}

// UnimplementedUserV1Server must be embedded to have forward compatible implementations.
type UnimplementedUserV1Server struct {
}

func (UnimplementedUserV1Server) Create(context.Context, *CreateRequest) (*CreateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}</span>
func (UnimplementedUserV1Server) Get(context.Context, *GetRequest) (*GetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}</span>
func (UnimplementedUserV1Server) Update(context.Context, *UpdateRequest) (*empty.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}</span>
func (UnimplementedUserV1Server) Delete(context.Context, *DeleteRequest) (*empty.Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}</span>
func (UnimplementedUserV1Server) mustEmbedUnimplementedUserV1Server() {<span class="cov0" title="0">}</span>

// UnsafeUserV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserV1Server will
// result in compilation errors.
type UnsafeUserV1Server interface {
        mustEmbedUnimplementedUserV1Server()
}

func RegisterUserV1Server(s grpc.ServiceRegistrar, srv UserV1Server) <span class="cov0" title="0">{
        s.RegisterService(&amp;UserV1_ServiceDesc, srv)
}</span>

func _UserV1_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Create(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/user_v1.UserV1/Create",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Create(ctx, req.(*CreateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserV1_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Get(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/user_v1.UserV1/Get",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Get(ctx, req.(*GetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserV1_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Update(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/user_v1.UserV1/Update",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Update(ctx, req.(*UpdateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserV1_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Delete(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/user_v1.UserV1/Delete",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserV1Server).Delete(ctx, req.(*DeleteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserV1_ServiceDesc is the grpc.ServiceDesc for UserV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserV1_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "user_v1.UserV1",
        HandlerType: (*UserV1Server)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Create",
                        Handler:    _UserV1_Create_Handler,
                },
                {
                        MethodName: "Get",
                        Handler:    _UserV1_Get_Handler,
                },
                {
                        MethodName: "Update",
                        Handler:    _UserV1_Update_Handler,
                },
                {
                        MethodName: "Delete",
                        Handler:    _UserV1_Delete_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "user.proto",
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "context"
        "log"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"

        desc "auth/pkg/user_v1"
)

func main() <span class="cov0" title="0">{
        // Cloud Run  TLS
        creds := credentials.NewClientTLSFromCert(nil, "")

        conn, err := grpc.NewClient(
                "auth-service-rxpqkfxb3a-uc.a.run.app:443",
                grpc.WithTransportCredentials(creds),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        c := desc.NewUserV1Client(conn)

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        r, err := c.Get(ctx, &amp;desc.GetRequest{Id: 12})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to get user: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf(" Success! User from Cloud: %+v", r.GetUser())</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
